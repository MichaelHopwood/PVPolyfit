"""
    .______   ____    ____ .______     ______    __      ____    ____  _______  __  .___________.
    |   _  \  \   \  /   / |   _  \   /  __  \  |  |     \   \  /   / |   ____||  | |           |
    |  |_)  |  \   \/   /  |  |_)  | |  |  |  | |  |      \   \/   /  |  |__   |  | `---|  |----`
    |   ___/    \      /   |   ___/  |  |  |  | |  |       \_    _/   |   __|  |  |     |  |     
    |  |         \    /    |  |      |  `--'  | |  `----.    |  |     |  |     |  |     |  |     
    | _|          \__/     | _|       \______/  |_______|    |__|     |__|     |__|     |__|     

PARAMETERS
----------
    DataFrames (train_df and test_df)
        a. Index: must be of form '%m/%d/%Y %H:%M:%S %p'
            i. Use pd.to_datetime(...).strptime('%m/%d/%Y %H:%M:%S %p') if change is necessary
        b. Value type must be numerical
        c. Columns must incude:
            i. Output (Y) column
            ii. input (xs) columns - used as covariates in linear square algorithm
                a. PVPolyfit allows for any number of input variables to be used
                    If you think a variable will have an effect on the output, include it in xs.
                    Naturally, it is ideal if these parameters are independent of one another.
                    However, the model should converge to low coefficients if the parameter is "double-counted".
            iii. Current (I) [if not already provided] - used in filtering technique
            iv. Global Horizontal Irradiance (GHI) - used for day classification
            v. PVLib's simulated clear sky GHI - used for day classification
                a. Check PVPolyfit.preprocessing's add_ghi_to_df for an example of this
                b. Or, go directly to the documentation: https://pvlib-python.readthedocs.io/en/stable/generated/pvlib.location.Location.get_clearsky.html
    Y_tag: str
        column name of output
    xs: list of str
        list of column names for covariates
    I_tag: str
        column name of Current
    ghi_tag: str
        column name of GHI input
    cs_tag: str
        column name of clearsky GHI generated by pvlib simulation (link below)
    highest_num_clusters: int
        num_clusters (or Types of Days) of which the algorithm iterates [1, highest_num_clusters]
            algorithm optimizes to best num_clusters within this range via RMSE
    highest_degree: int
        degree of which the algorithm iterates [1, highest_degree]
            algorithm optimizes to best degree for each day via RMSE
    kernel_type: int
        type of regression kernel, 3 are currently available
            0: polynomial
                paraboiloidal polynomial 
                i.e. degree 2 with 2 covariates (dynamic equation): Y(α , X) = α_0 + α_1 X_1 + α_2 X_2 + α_3 X_1 X_2 + α_4 X_1^2 + α_5 X_2^2
            1: polynomial with included log(POA) parameter
                *requires xs[0] be POA column
                paraboiloidal polynomial with added log(POA) term
            2: diode-inspired mathematical model
                *requires that xs be [POA, Temp]
                Originally intended for modelling voltage
                (static equation):  Y(α , X) = α_0 + α_1 POA + α_2 Temp + α_3 ln(POA) + α_4 ln(Temp)
    Y_high_filter: int
        TO BE DEPRICATED: Used in filtering process, filter out Y values higher than Y_high_filter
        Used in cases where outages cause high values to be published
    min_count_per_day: int, usually 8
        After filtering, if a day has too few values left, eliminate the day
    plot_graph: bool
        True, will plot the chosen graph, graph_type
    graph_type: str
        Choose type of graph - currently only one available
            'regression': show time-series rendering of measured and modelled data on test days
    print_info: bool
        Display information about filtering, clustering, etc. for each model/day
    
RETURNS
-------
    modelled_Y: list of lists
        Each sublist is the model output during that index's day
        i.e. modelled_Y[0] is the first day's list of modelled output values

    days_rmse, list of floats
        RMSE for each day
"""

'''
#
## Use PVPolyfit in 5 simple steps
#

   # 0. make sure you have installed PVPolyfit, using `pip install pvpolyfit`
'''

'''# 1. Import necessary packages'''
from PVPolyfit.core import pvpolyfit
import pandas as pd

'''# 2. Import data'''
train_df = pd.read_csv('example_data//train_df.csv', index_col = 'datetime')
test_df = pd.read_csv('example_data//test_df.csv', index_col = 'datetime')

'''# 3. Define input variables'''
Y_tag = 'Pmpp'
xs = ['irradiance', 'ambient_temp'] # Try throwing in 'wind_speed', does it effect the results?
I_tag = 'Impp'
ghi_tag = 'GHI'
cs_tag = 'pvlib_GHI'
highest_num_clusters = 15
highest_degree = 10
kernel_type = 0 
Y_high_filter = 10000 # To be depricated: filter out Y values higher than Y_high_filter
min_count_per_day = 8


'''# 4. Call function'''
modelled_P, days_rmses = pvpolyfit(train_df, test_df, Y_tag, xs, I_tag, ghi_tag, cs_tag, 
	      highest_num_clusters, highest_degree, kernel_type, Y_high_filter, min_count_per_day, 
              plot_graph = True, graph_type = 'regression', print_info = False)

'''# 5. Understanding the error - simple example'''
# calculate average rmse
avg_RMSE = sum(days_rmses) / len(days_rmses)

# Flatten out list originally: [[Day 0 modelled_P], [Day 1 modelled_P], ...]
flattened_modelled_P = [item for sublist in modelled_P for item in sublist]
max_P = max(flattened_modelled_P)

# Display performance indicators
print("Average RMSE in test dataset: {:.4f} W".format(avg_RMSE))
print("Or, equivalently {:.4f}% of max".format((avg_RMSE / max_P)*100))
